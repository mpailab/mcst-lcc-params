# пример конфигурационногоа файла
# если у параметра нет описания, то у него есть подробное описание в global_vars.py
# в конфигурационном файле всюду вместо True/False должно быть 1/0
# параметры модулей draw и analyse можно удалить

##
# Модуль weight
##

PROC_WEIGHT_SETUP = 1
TASK_WEIGHT_SETUP = 1
NODE_WEIGHT_SETUP = 0
REGN_WEIGHT_SETUP = 0
ICV_REGN_WEIGHT_SETUP = 0
SECT_WEIGHT_SETUP = 1

##
# Модуль read
##

# Каталог с файлами <specname>.txt
# В файле <specname>.txt для каждой процедуры спека <specname>, являющейся одновременно исполняемой и компилируемой,
# содержится общее время ее работы
PROC_ORDER_PATH = ./spec/analyse/proc_order

# Каталог с файлами <specname>.txt
# Каждый такой файл хранит пересечение списков компилируемых и исполняемых процедур спека <specname>
PROC_LIST_PATH = ./spec/analyse/proc_list

# Каталог, в котором содержится информация, о времени работы всех исполняемых процедур (но необязательно компилируемых)
# для каждого спека
STATEXEC_PATH = ./spec/stat/exec

# Вес, который присваевается каждой компилируемой, но неисполняемой процедуре
UNEXEC_PROC_WEIGHT = 1.

# Принимать во внимание компилируемые, но неисполняемые процедуры? {0, 1}
USE_FULL_STAT = 1

# Каталог со статистикой по всем компилируемым процедурам по всем спекам
FULL_STAT_PATH = ./spec/stat/comp_all/stat

# Каталог, из которой производиться считывание статистики
# Если мы решили сами собирать статистику, то надо выставить STAT_PATH_FOR_READ != FULL_STAT_PATH
STAT_PATH_FOR_READ = ./spec/stat/comp_all/stat

##
# Модуль stat_adaptation
##

# Учитывать при обработки статистики динамическое изменение числа операций в процедуре во время фазы regions? {0, 1}
DINUMIC_PROC_OPERS_NUM = 0
# Учитывать при обработки статистики динамическое изменение числа операций в регионах процедуры во время фазы regions? {0, 1}
DINUMIC_REGN_OPERS_NUM = 0


##
# dcs
##

# Номер последнего существующего уровня оптимизации фазы dcs
MAX_DCS_LEVEL = 4

# Полезность dcs оптимизации для процедуры определяется формулой:
# impotance = DCS_KOEF_NODE_IMPOTANCE * nd + DCS_KOEF_EDGE_IMPOTANCE * ed + DCS_KOEF_LOOP_IMPOTANCE * ld,
# где nd -- процент найденных мертвых узлов,
#     ed -- процент найденных мертвых циклов,
#     ld -- процент найденных мертвых циклов.
DCS_KOEF_NODE_IMPOTANCE = 1
DCS_KOEF_EDGE_IMPOTANCE = 1
DCS_KOEF_LOOP_IMPOTANCE = 1

# Если полезность dcs оптимизации <= DSC_IMPOTANCE_LIMIT, то dcs оптимизация считается бесполезной
DSC_IMPOTANCE_LIMIT = 0.001

##
# Модуль analyse
##

# Каталог, в котором хранятся логи запусков оптимизации методом имитации отжига
RUN_LOGS_PATH = ./result_from_real_data

# Предполагаемая процентная величина погрешности определения времени исполнения, компиляции, объема потребляемой памяти, и т.п.
DEVIATION_PERCENT_OF_TcTeMemF = 0.01

##
# Опции сглаживания статистики (модуль smooth_stat)
##

# Сглаживать статистику? {0, 1}
SMOOTH_STAT = 1
# Чем меньше следующие коэффиценты, тем сильнее сглаживание
ERF_KOEF_FOR_CONTINUOUS_PAR = 20 # коэффициент сглаживания для вещественных параметров
ERF_KOEF_FOR_DISCRETE_PAR = 0.5 # коэффициент сглаживания для целичисленных параметров

# Чем ниже следующие параметры, тем качественнее сглаживание
# Уменьшение следующих параметров может очень существенно замедлить сглаживание!
# Доля исходного веса, которая не будет участвовать в сглаживании
ZERO_LIMIT_FOR_ERF = 0.01
# Порог для абсолютных значений весов, веса ниже которого не будут сглаживаться
ZERO_LIMIT_FOR_WEIGHT = 0.001


##
# Модуль calculate_TcTeMem
##

# Путь до скрипта, который запускает компиляцию спека, и возвращает время компиляции
SCRIPT_COMP = ./choice/__run_comp.sh
# Путь до скрипта, который запускает исполнение спека, и возвращает время исполнения
SCRIPT_EXEC = ./choice/__run_exec.sh
# Путь до скрипта, который запускает компиляцию спека вместе со сбором статистики, и возвращает объем потребляемой памяти
SCRIPT_COMP_WITH_STAT = ./choice/__run_comp_with_stat.sh


##
# Модуль draw
##

# Количество столбцов на генерируемых графиках
PAR_DIAG_COL_NUM = 100
# Отображать на экран генерируемые графики? {0, 1}
SHOW_FLAG = 0
# Сохранять генерируемые графики? {0, 1}
SAVE_PIC_FLAG = 1
# Каталог, в который будут сохраняться генерируемые графики
IMAGES_SAVE_MAIN_DIR = ./images
# Структура подкаталогов, в соответствии с которой будут распределяться сохраняемые графики {0, 1, 2}
# 0 -> нет подкаталогов
# 1 -> taskname/...
# 2 -> parname/...
SAVE_SUBDIR_STRUCTURE_MODE = 2
# Опция включает отрисовку на графиках результатов запуска оптимизации
DRAW_RUN_RESULTS_ON_GRAPHICS = 1


##
# Модуль optimize
##

# Актуализировать статистику на каждом шаге метода отжига? {0, 1}
GAIN_STAT_ON_EVERY_OPTIMIZATION_STEP = 1

PAR_DISTRIBUTION_DATABASE = 1

# Начальное значение температуры: (0, 1]
START_TEMPERATURE = 0.5

# Закон убывания температуры: {0, 1, 2}
# 0 -> 1 / ln(n + 1)
# 1 -> 1 / n
# 2 -> alpha ^ n
TEMPERATURE_LAW_TYPE = 2
# значение alpha
ALPHA_IN_TEPMERATURE_LAW = 0.7

# Тип вероятностного распределения,
# определяющего выбор следующего состояния системы в зависимости от ее текущих состояния и температуры: {0, 1, 2, 3}
# 0 -> нормальное распределение
# 1 -> распределение для сверхбыстрого отжига
# 2 -> распределение Коши
# 3 -> равномерное распределение
DISTRIBUTION_LAW_TYPE = 1

USE_RELATIONS_OF_PARAMETORS = 1
# Значения коэффицентов минимизируемого функционала
TIME_EXEC_IMPOTANCE = 5
TIME_COMP_IMPOTANCE = 1
MEMORY_IMPOTANCE = 1
# Допустимый процент увеличения времени компиляции
COMP_TIME_INCREASE_ALLOWABLE_PERCENT = 0.25
# Допустимый процент увеличения времени исполнения
EXEC_TIME_INCREASE_ALLOWABLE_PERCENT = 0.05
# Допустимый процент увеличения объема потребляемой памяти
MEMORY_INCREASE_ALLOWABLE_PERCENT = 0.50

# Число итераций метода отжига
MAX_NUMBER_ITERATIONS = 10

# Максимальное число попыток выбора новых значений параметров для каждой итерации метода отжига
MAX_NUMBER_OF_ATTEMPTS_FOR_ITERATION = 10

# Уменьшать значение температуры после итераций, на которых не был осуществлен переход к лучшему значению? {0, 1}
DECREASE_TEMPERATURE_BEFORE_UNFORTUNATE_ITERATIONS = 1


# Стратегия
# Синтаксис:
#        <стратегия>            ::= <группа параметров> | <стратегия>; <группа параметров>
#        <группа параметров>   ::= <параметр> | <группа параметров> <параметр>
OPTIMIZATION_STRATEGY = dcs; disable_regions_nesting; regn_max_proc_op_sem_size regn_opers_limit; regn_heur1 regn_heur2 regn_heur3 regn_heur4; ifconv_opers_num ifconv_calls_num ifconv_merge_heur

# Список оптимизируемых спеков
# Синтаксис:
#        <список спеков>   ::= <спек> | <список спеков>, <спек>
#        <спек>            ::= <имя спека> | <имя спека> : <список процедур>
#        <список процедур> ::= <процедура> | <список процедур> <процедура>
specs = 541.leela, 519.lbm, 508.namd

# Последовательная оптимизация? {0, 1}
# 0 -> независимая оптимизация по каждой группе в стратегии
# 1 -> последовательная оптимизация согласно стратегии
SEQ_OPTIMIZATION_WITH_STRATEGY = 1

# Синхронная оптимизация? {0, 1}
# 0 -> независимая оптимизация каждого спека
# 1 -> синхранная оптимизация спеков
SYNCHRONOUS_OPTIMIZATION_FOR_SPECS = 1

OUTPUTDIR = "./doc/test_output"
