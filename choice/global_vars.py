#!/usr/bin/python
# -*- coding: utf-8 -*-
 
""" содержит инициализацию глобальных переменных для всего проекта
"""

# Значения по-умолчанию для параметров будет считывать из компилятора сразу в модуль par

##
# Модуль weight
##
""" Конечный вес каждого узла фазы regions определяется формулой pr_norm(nd_norm(w_n * w_r) * w_p * w_t), где
    w_n -- начальный вес узла,
    w_r -- вес региона,
    nd_norm -- нормирование по всем узлам процедуры,
    w_p -- вес процедуры,
    w_t -- вес спека,
    pr_norm -- нормирование по всем расматриваемым процедурам (всех рассматриваемых спеков)
    
    Конечный вес сливаемого участка в фазе if_conv определяется формулой pr_norm(s_norm(w_s * w_ir) * w_p * w_t), где
    w_s -- начальный вес сливаемого участка
    w_ir -- вес региона, к которому относится сливаемый участок
    s_norm -- нормирование по всем сливаемым участкам процедуры
"""

""" Режим учета веса процедуры w_p: 0, 1
    0 -> w_p = 1 (не учитывать вес процедуры)
    1 -> w_p -- временя работы процедуры в составе спека (ненормированное)
"""
PROC_WEIGHT_SETUP = 1

""" Режим учета веса спека w_t: 0, 1
    0 -> w_t = 1 (не учитывать вес спека)
    1 -> w_t -- отношение времени исполнения собственных (небиблиотечных) процедур спека к общему времени его работы
"""
TASK_WEIGHT_SETUP = 1

""" Режим определения начального веса узла w_n: 0, 1, 2, 3
    0 -> w_n = 0, если счетчик узла во всей процедуре (n_cnt) равен нулю;
         w_n = 1, иначе
    1 -> w_n -- внутренний счетчик узла (v_cnt)
    2 -> w_n -- счетчик узла во всей процедуре (n_cnt) 
    3 -> w_n -- отношения внутреннего счетчика узла к счетчику узла во всей процедуре (v_cnt / n_cnt);
         однако если n_cnt = 0, то w_n полагается равным нулю
"""
NODE_WEIGHT_SETUP = 0

""" Режим учета веса региона w_r фазы regions: 0, 1, 2
    0 -> w_r = 1 (не учитывать вес региона)
    1 -> w_r -- счетчик региона
    2 -> w_r -- счетчик региона, нормируемый по всем регионам в процедуре
"""
REGN_WEIGHT_SETUP = 0

""" Режим учета веса региона w_ir фазы if_conv: 0, 1, 2
    0 -> w_ir = 1 (не учитывать вес региона)
    1 -> w_ir -- счетчик региона
    2 -> w_ir -- счетчик региона, нормируемый по всем регионам в процедуре
"""
ICV_REGN_WEIGHT_SETUP = 0 # {0, 1, 2}

""" Режим учета веса сливаемого участка w_s: 0, 1
    0 -> w_s = 1 (не учитывать вес сливаемого участка)
    1 -> w_s -- счетчик сливаемого участка
"""
SECT_WEIGHT_SETUP = 1 # {1, 0}


##
# Модуль read
##

# Каталог с файлами <specname>.txt
# В файле <specname>.txt для каждой процедуры спека <specname>, являющейся одновременно исполняемой и компилируемой,
# содержится общее время ее работы
PROC_ORDER_PATH = './spec/analyse/proc_order'

# Каталог с файлами <specname>.txt
# Каждый такой файл хранит пересечение списков компилируемых и исполняемых процедур спека <specname>
PROC_LIST_PATH = './spec/analyse/proc_list'

# Каталог, в котором содержится информация, о времени работы всех исполняемых процедур (но необязательно компилируемых)
# для каждого спека
STATEXEC_PATH = './spec/stat/exec'

# Вес, который присваевается каждой компилируемой, но неисполняемой процедуре
UNEXEC_PROC_WEIGHT = 1.

# Принимать во внимание компилируемые, но неисполняемые процедуры? {True, False}
USE_FULL_STAT = False

# Каталог со статистикой по всем компилируемым процедурам по всем спекам
FULL_STAT_PATH = './spec/stat/comp_all/stat'

# Каталог, из которой производиться считывание статистики
# Если мы решили сами собирать статистику, то надо выставить STAT_PATH_FOR_READ != FULL_STAT_PATH
STAT_PATH_FOR_READ = FULL_STAT_PATH

##
# Модуль stat_adaptation
##

# Учитывать при обработки статистики динамическое изменение числа операций в процедуре во время фазы regions
DINUMIC_PROC_OPERS_NUM = False
# Учитывать при обработки статистики динамическое изменение числа операций в регионах процедуры во время фазы regions
DINUMIC_REGN_OPERS_NUM = False


##
# dcs
##

# Номер последнего существующего уровня оптимизации фазы dcs
MAX_DCS_LEVEL = 4
# Cписко всех уровней оптимизации dcs, кроме нулевого
DCS_LEVELS = range(1, MAX_DCS_LEVEL + 1)

# Полезность dcs оптимизации для процедуры определяется формулой:
# impotance = DCS_KOEF_NODE_IMPOTANCE * nd + DCS_KOEF_EDGE_IMPOTANCE * ed + DCS_KOEF_LOOP_IMPOTANCE * ld,
# где nd -- процент найденных мертвых узлов,
#     ed -- процент найденных мертвых циклов,
#     ld -- процент найденных мертвых циклов.
DCS_KOEF_NODE_IMPOTANCE = 1
DCS_KOEF_EDGE_IMPOTANCE = 1
DCS_KOEF_LOOP_IMPOTANCE = 1

# Если полезность dcs оптимизации <= DSC_ZERO_LIMIT, то dcs оптимизация считается бесполезной
DSC_ZERO_LIMIT = 0.001

##
# Модуль analyse
##

# Каталог, в котором хранятся логи запусков метода имитации отжига
RUN_LOGS_PATH = './result_from_real_data'

# Предполагаемая процентная величина погрешности определения времени исполнения, компиляции, объема потребляемой памяти, и т.п.
DEVIATION_PERCENT_OF_TcTeMemF = 0.01

##
# Опции сглаживания статистики (модуль smooth_stat)
##

# Включение сглаживания статистики
SMOOTH_STAT = True
# Чем меньше следующие коэффиценты, тем сильнее сглаживание
ERF_KOEF_FOR_CONTINUOUS_PAR = 20 # коэффициент сглаживания для вещественных параметров
ERF_KOEF_FOR_DISCRETE_PAR = 0.5 # коэффициент сглаживания для целичисленных параметров
# Порог, значения ниже которого отбрасываются, при определении доли оставшегося для распределения веса
ZERO_LIMIT_FOR_ERF = 0.01
# Веса ниже следующего значения не будут сглаживаться
ZERO_LIMIT_FOR_WEIGHT = 0.001


##
# Модуль calculate_TcTeMem
##

SCRIPT_COMP = './choice/run_comp.sh'
SCRIPT_EXEC = './choice/run_exec.sh'
# SCRIPT_COMP_WITH_STAT компилирует, собирает статистику и печатает объем затраченной памяти
SCRIPT_COMP_WITH_STAT = './choice/run_comp_with_stat.sh'


##
# Модуль draw
##

# количество столбцов на диаграммах
PAR_DIAG_COL_NUM = 100
# Опция включает отображение на экран всех генерируемых графиков
SHOW_FLAG = False
# Если опция включена, то генерируемые графики будут сохраняться
SAVE_PIC_FLAG = True
# Путь до каталога, в который будут сохраняться генерируемые графики
IMAGES_SAVE_MAIN_DIR = './images'
# Опция определяет структуру подкаталогов, в соответствии с которой будут распределяться сохраняемые графики
# 0 -> нет подкаталогов
# 1 -> taskname/...
# 2 -> parname/...
SAVE_SUBDIR_STRUCTURE_MODE = 2
# Опция включает отрисовку на графиках результатов запуска оптимизации
DRAW_RUN_RESULTS_ON_GRAPHICS = True


##
# Модуль optimize
##

# Хранить в оперативной памяти, вычисленные на предыдущих шагах оптимизации распределения? {True, False}
PAR_DISTRIBUTION_DATABASE = True

# Начальное значение температуры
START_TEMPERATURE = 0.5 # Range of temperature: (0, 1].

# Закон убывания температуры: {0, 1, 2}
# 0 -> 1 / ln(n + 1)
# 1 -> 1 / n
# 2 -> alpha ^ n
TEMPERATURE_LAW_TYPE = 2
# значение alpha
ALPHA_IN_TEPMERATURE_LAW = 0.7
# Тип вероятностного распределения, определяющего выбор следующего состояния системы в зависимости от ее текущих состояния и температуры
# {0, 1, 2, 3}
# 0 -> нормальное распределение
# 1 -> распределение для сверхбыстрого отжига
# 2 -> распределение Коши
# 3 -> равномерное распределение
DISTRIBUTION_LAW_TYPE = 1

USE_RELATIONS_OF_PARAMETORS = True
GAIN_STAT_ON_EVERY_OPTIMIZATION_STEP = True
KOEF_TIME_EXEC_IMPOTANCE = 5
MAX_NUMBER_ITERATIONS = 10
MAX_NUMBER_OF_ATTEMPTS_FOR_ITERATION = 10
# Уменьшать значение температуры после итераций, на которых не был осуществлен переход к лучшему значению
DECREASE_TEMPERATURE_BEFORE_UNFORTUNATE_ITERATIONS = True
COMP_TIME_INCREASE_ALLOWABLE_PERCENT = 0.25
EXEC_TIME_INCREASE_ALLOWABLE_PERCENT = 0.05
MEMEMORY_INCREASE_ALLOWABLE_PERCENT = 0.50
